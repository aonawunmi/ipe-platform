import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Order, OrderSide, OrderStatus } from './order.entity';
import { MarketsService } from '../markets/markets.service';
import { MarketStatus } from '../markets/market.entity';
import { MatchingEngineService } from './matching-engine.service';
import { WalletsService } from '../wallets/wallets.service';

@Injectable()
export class OrdersService {
  constructor(
    @InjectRepository(Order)
    private ordersRepository: Repository<Order>,
    private marketsService: MarketsService,
    private matchingEngine: MatchingEngineService,
    private walletsService: WalletsService,
  ) {}

  /**
   * Place a new order (buy YES or NO shares)
   */
  async placeOrder(orderData: {
    marketId: string;
    userId: string;
    side: OrderSide;
    price: number;
    quantity: number;
  }): Promise<Order> {
    try {
      // Get user's wallet
      const wallet = await this.ordersRepository.query(
        'SELECT id FROM wallets WHERE user_id = $1',
        [orderData.userId],
      );

      if (!wallet || wallet.length === 0) {
        throw new BadRequestException('User wallet not found');
      }

      const walletId = wallet[0].id;

    // Validate market exists and is active
    const market = await this.marketsService.findById(orderData.marketId);
    if (market.status !== MarketStatus.ACTIVE) {
      throw new BadRequestException('Market is not active for trading');
    }

    // Validate price is within 0-10000 basis points
    if (orderData.price < 0 || orderData.price > 10000) {
      throw new BadRequestException(
        'Price must be between 0 and 10000 basis points',
      );
    }

    // Validate quantity is positive
    if (orderData.quantity <= 0) {
      throw new BadRequestException('Quantity must be greater than 0');
    }

    // Calculate amount to lock (as string for bigint column)
    // For YES: lock (price * quantity) / 10000
    // For NO: lock ((10000 - price) * quantity) / 10000
    const amountLocked =
      orderData.side === OrderSide.YES
        ? String(Math.floor((orderData.price * orderData.quantity) / 10000))
        : String(Math.floor(((10000 - orderData.price) * orderData.quantity) / 10000));

      // Check wallet balance and lock funds
      await this.walletsService.lockFunds(
        orderData.userId,
        amountLocked,
        'pending', // Will be updated with order ID after creation
      );

    // Create order (order_number will be auto-generated by database trigger)
    const order = this.ordersRepository.create({
      marketId: orderData.marketId,
      userId: orderData.userId,
      walletId: walletId,
      side: orderData.side,
      price: orderData.price,
      quantity: orderData.quantity,
      amountLocked,
      status: OrderStatus.PENDING,
    });

    // Save order and trigger matching engine
    const savedOrder = await this.ordersRepository.save(order);

      // Trigger order matching engine asynchronously
      this.matchingEngine.matchOrder(savedOrder.id).catch((error) => {
        console.error('Error matching order:', error);
      });

      return savedOrder;
    } catch (error) {
      console.error('Error placing order:', error);
      throw error;
    }
  }

  /**
   * Get user's orders
   */
  async getUserOrders(userId: string, filters?: {
    marketId?: string;
    status?: OrderStatus;
  }): Promise<Order[]> {
    const query = this.ordersRepository
      .createQueryBuilder('order')
      .where('order.userId = :userId', { userId });

    if (filters?.marketId) {
      query.andWhere('order.marketId = :marketId', {
        marketId: filters.marketId,
      });
    }

    if (filters?.status) {
      query.andWhere('order.status = :status', { status: filters.status });
    }

    query.orderBy('order.createdAt', 'DESC');

    return query.getMany();
  }

  /**
   * Get market's order book (open orders grouped by price)
   */
  async getOrderBook(marketId: string): Promise<{
    yes: { price: number; quantity: number }[];
    no: { price: number; quantity: number }[];
  }> {
    // Get all open orders for this market
    const orders = await this.ordersRepository.find({
      where: {
        marketId,
        status: OrderStatus.OPEN,
      },
      order: {
        price: 'DESC',
      },
    });

    // Group YES orders by price
    const yesOrders = orders
      .filter((o) => o.side === OrderSide.YES)
      .reduce(
        (acc, order) => {
          const existing = acc.find((item) => item.price === order.price);
          if (existing) {
            existing.quantity += order.quantity - order.quantityFilled;
          } else {
            acc.push({
              price: order.price,
              quantity: order.quantity - order.quantityFilled,
            });
          }
          return acc;
        },
        [] as { price: number; quantity: number }[],
      );

    // Group NO orders by price
    const noOrders = orders
      .filter((o) => o.side === OrderSide.NO)
      .reduce(
        (acc, order) => {
          const existing = acc.find((item) => item.price === order.price);
          if (existing) {
            existing.quantity += order.quantity - order.quantityFilled;
          } else {
            acc.push({
              price: order.price,
              quantity: order.quantity - order.quantityFilled,
            });
          }
          return acc;
        },
        [] as { price: number; quantity: number }[],
      );

    return {
      yes: yesOrders,
      no: noOrders,
    };
  }

  /**
   * Cancel an order
   */
  async cancelOrder(orderId: string, userId: string): Promise<Order> {
    const order = await this.ordersRepository.findOne({
      where: { id: orderId, userId },
    });

    if (!order) {
      throw new NotFoundException('Order not found');
    }

    if (
      order.status !== OrderStatus.OPEN &&
      order.status !== OrderStatus.PARTIALLY_FILLED
    ) {
      throw new BadRequestException('Order cannot be cancelled');
    }

    order.status = OrderStatus.CANCELLED;
    order.cancelledAt = new Date();

    return this.ordersRepository.save(order);
  }

  /**
   * Get order by ID
   */
  async findById(id: string): Promise<Order> {
    const order = await this.ordersRepository.findOne({ where: { id } });
    if (!order) {
      throw new NotFoundException(`Order with ID ${id} not found`);
    }
    return order;
  }

  /**
   * Generate unique order number
   */
  private async generateOrderNumber(): Promise<string> {
    const count = await this.ordersRepository.count();
    const year = new Date().getFullYear();
    return `ORD-${year}-${String(count + 1).padStart(6, '0')}`;
  }

  /**
   * Update order status (internal use)
   */
  async updateOrderStatus(
    orderId: string,
    status: OrderStatus,
    quantityFilled?: number,
    amountFilled?: string,
  ): Promise<Order> {
    const order = await this.findById(orderId);
    order.status = status;

    if (quantityFilled !== undefined) {
      order.quantityFilled = quantityFilled;
    }

    if (amountFilled !== undefined) {
      order.amountFilled = amountFilled;
    }

    if (status === OrderStatus.FILLED) {
      order.filledAt = new Date();
    }

    return this.ordersRepository.save(order);
  }
}
